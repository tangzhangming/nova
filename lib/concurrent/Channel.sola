// Sola 标准库 - 通道
namespace sola.concurrent

use sola.lang.RuntimeException;
use sola.concurrent.SelectCase;

/**
 * 通道 - 协程间通信的管道
 * 
 * Channel 是协程间通信的主要机制，遵循 CSP（Communicating Sequential Processes）模型。
 * 
 * 特性：
 * - 类型安全：编译期检查通道元素类型
 * - 阻塞语义：无缓冲通道发送/接收会阻塞
 * - 缓冲支持：有缓冲通道可减少阻塞
 * - 关闭语义：关闭后不能发送，但可以继续接收缓冲数据
 * - OOP select：Channel::select() 方法替代 select 语句
 * 
 * @template T 元素类型
 * 
 * 使用示例:
 * ```sola
 * use sola.concurrent.{Channel, Coroutine, SelectCase};
 * 
 * // 创建无缓冲通道
 * $ch := new Channel<int>();
 * 
 * // 启动生产者协程
 * Coroutine::spawn((): void => {
 *     $ch->send(42);
 * });
 * 
 * // 接收数据
 * $value := $ch->receive();
 * echo $value;  // 42
 * 
 * // 创建有缓冲通道
 * $buffered := new Channel<string>(10);
 * $buffered->send("hello");  // 不会阻塞
 * 
 * // 多路复用（OOP 风格）
 * Channel::select([
 *     SelectCase::recv($ch1, (int $v): void => echo $v),
 *     SelectCase::recv($ch2, (string $s): void => echo $s),
 *     SelectCase::timeout(5000, (): void => echo "超时"),
 * ]);
 * ```
 */
public class Channel<T> {
    
    /** 内部句柄（VM 层实现） */
    private int $handle;
    
    /** 缓冲区容量 */
    private int $capacity;
    
    /** 是否已关闭 */
    private bool $closed;
    
    /**
     * 创建通道
     * 
     * @param int $capacity 缓冲区容量（0 表示无缓冲通道）
     */
    public function __construct(int $capacity = 0) {
        $this->capacity = $capacity;
        $this->closed = false;
        // 注意：实际的通道创建在 VM 层完成
        // 这里只是存储配置信息
    }
    
    /**
     * 发送数据到通道（阻塞）
     * 
     * 如果通道已满或无缓冲且无接收者，当前协程会阻塞。
     * 
     * @param T $value 要发送的值
     * @throws ChannelClosedException 通道已关闭
     */
    public function send(T $value): void {
        if ($this->closed) {
            throw new ChannelClosedException("cannot send on closed channel");
        }
        // VM 层实现阻塞发送
    }
    
    /**
     * 从通道接收数据（阻塞）
     * 
     * 如果通道为空且未关闭，当前协程会阻塞。
     * 
     * @return T 接收到的值
     * @throws ChannelClosedException 通道已关闭且为空
     */
    public function receive(): T {
        // VM 层实现阻塞接收
    }
    
    /**
     * 尝试发送（非阻塞）
     * 
     * @param T $value 要发送的值
     * @return bool 是否成功发送
     */
    public function trySend(T $value): bool {
        if ($this->closed) {
            return false;
        }
        // VM 层实现非阻塞发送
        return false;
    }
    
    /**
     * 尝试接收（非阻塞）
     * 
     * @return ?T 接收到的值，如果通道为空返回 null
     */
    public function tryReceive(): ?T {
        // VM 层实现非阻塞接收
        return null;
    }
    
    /**
     * 关闭通道
     * 
     * 关闭后：
     * - 不能再发送（会抛出异常）
     * - 可以继续接收缓冲区中的数据
     * - 缓冲区为空时，接收返回零值
     */
    public function close(): void {
        $this->closed = true;
        // VM 层实现关闭
    }
    
    /**
     * 检查通道是否已关闭
     */
    public function isClosed(): bool {
        return $this->closed;
    }
    
    /**
     * 获取缓冲区容量
     */
    public function capacity(): int {
        return $this->capacity;
    }
    
    /**
     * 获取当前缓冲的元素数量
     */
    public function length(): int {
        // VM 层实现
        return 0;
    }
    
    // =========================================================================
    // 静态方法
    // =========================================================================
    
    /**
     * 多路复用选择（OOP 风格的 select）
     * 
     * 等待多个通道操作中的一个完成。这是 select 语句的 OOP 替代方案。
     * 
     * @param SelectCase[] $cases 选择分支数组
     * @return int 被选中的 case 索引（-1 表示执行了 default）
     * 
     * @example
     * ```sola
     * use sola.concurrent.{Channel, SelectCase};
     * 
     * Channel<int> $ch1 = new Channel<int>();
     * Channel<string> $ch2 = new Channel<string>();
     * 
     * Channel::select([
     *     SelectCase::recv($ch1, (int $v): void => {
     *         echo "收到整数: " + $v;
     *     }),
     *     SelectCase::recv($ch2, (string $s): void => {
     *         echo "收到字符串: " + $s;
     *     }),
     *     SelectCase::timeout(5000, (): void => {
     *         echo "等待超时";
     *     }),
     * ]);
     * ```
     */
    public static function select(SelectCase[] $cases): int {
        // VM 内置实现
        return -1;
    }
    
    /**
     * 合并多个通道为一个
     * 
     * 创建一个新通道，从所有输入通道接收数据。
     * 当所有输入通道都关闭时，输出通道也会关闭。
     * 
     * @template T 元素类型
     * @param Channel<T>[] $channels 要合并的通道数组
     * @return Channel<T> 合并后的通道
     * 
     * @example
     * ```sola
     * $merged := Channel::merge([$ch1, $ch2, $ch3]);
     * foreach ($merged as $value) {
     *     echo $value;  // 来自任意通道的值
     * }
     * ```
     */
    public static function merge<T>(Channel<T>[] $channels): Channel<T> {
        // VM 内置实现
    }
}
