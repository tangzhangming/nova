// Sola 标准库 - 优先队列
namespace sola.collections

/**
 * 优先队列
 * 
 * 基于二叉堆实现的优先队列。
 * 
 * 特点：
 * - 入队 O(log n)
 * - 出队 O(log n)
 * - 查看队首 O(1)
 * - 默认最小堆（最小元素优先）
 * 
 * @template T 元素类型
 * 
 * 使用示例:
 * ```sola
 * use sola.collections.PriorityQueue;
 * 
 * $pq := new PriorityQueue<int>();
 * $pq->add(3);
 * $pq->add(1);
 * $pq->add(2);
 * 
 * echo $pq->poll();  // 1
 * echo $pq->poll();  // 2
 * echo $pq->poll();  // 3
 * ```
 */
public class PriorityQueue<T> implements IQueue<T> {
    
    /** 堆数组 */
    private array $heap;
    
    /** 元素数量 */
    private int $count;
    
    /** 比较器 */
    private IComparator<T> $comparator;
    
    /** 修改计数 */
    private int $modCount;
    
    /**
     * 创建空的优先队列
     * 
     * @param comparator 比较器（可选，null则使用自然顺序）
     */
    public function __construct(IComparator<T> $comparator = null) {
        $this->heap = [];
        $this->count = 0;
        $this->comparator = $comparator;
        $this->modCount = 0;
    }
    
    /**
     * 创建最大堆（最大元素优先）
     */
    public static function maxHeap<T>(): PriorityQueue<T> {
        return new PriorityQueue<T>(new ReverseComparator<T>());
    }
    
    /**
     * 从数组创建优先队列
     */
    public static function fromArray<T>(array $array, IComparator<T> $comparator = null): PriorityQueue<T> {
        $pq := new PriorityQueue<T>($comparator);
        foreach ($array as $item) {
            $pq->add($item);
        }
        return $pq;
    }
    
    // ========================================================================
    // IQueue 实现
    // ========================================================================
    
    public function enqueue(mixed $element): bool {
        return $this->add($element);
    }
    
    public function offer(mixed $element): bool {
        return $this->add($element);
    }
    
    public function dequeue(): mixed {
        if ($this->count == 0) {
            throw new NoSuchElementException("Queue is empty");
        }
        return $this->poll();
    }
    
    public function poll(): mixed {
        if ($this->count == 0) {
            return null;
        }
        
        $result := $this->heap[0];
        $this->count--;
        
        if ($this->count > 0) {
            $this->heap[0] = $this->heap[$this->count];
            $this->siftDown(0);
        }
        
        $this->modCount++;
        return $result;
    }
    
    public function front(): mixed {
        if ($this->count == 0) {
            throw new NoSuchElementException("Queue is empty");
        }
        return $this->heap[0];
    }
    
    public function peek(): mixed {
        if ($this->count == 0) {
            return null;
        }
        return $this->heap[0];
    }
    
    // ========================================================================
    // ICollection 实现
    // ========================================================================
    
    public function size(): int {
        return $this->count;
    }
    
    public function isEmpty(): bool {
        return $this->count == 0;
    }
    
    public function contains(mixed $element): bool {
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->heap[$i] == $element) {
                return true;
            }
        }
        return false;
    }
    
    public function containsAll(ICollection<T> $collection): bool {
        foreach ($collection as $item) {
            if (!$this->contains($item)) {
                return false;
            }
        }
        return true;
    }
    
    public function add(mixed $element): bool {
        $this->heap[$this->count] = $element;
        $this->siftUp($this->count);
        $this->count++;
        $this->modCount++;
        return true;
    }
    
    public function addAll(ICollection<T> $collection): bool {
        foreach ($collection as $item) {
            $this->add($item);
        }
        return true;
    }
    
    public function remove(mixed $element): bool {
        $index := -1;
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->heap[$i] == $element) {
                $index = $i;
                break;
            }
        }
        
        if ($index < 0) {
            return false;
        }
        
        $this->removeAt($index);
        return true;
    }
    
    public function removeAll(ICollection<T> $collection): bool {
        $modified := false;
        foreach ($collection as $item) {
            while ($this->remove($item)) {
                $modified = true;
            }
        }
        return $modified;
    }
    
    public function retainAll(ICollection<T> $collection): bool {
        $modified := false;
        $newHeap := [];
        $newCount := 0;
        
        for ($i := 0; $i < $this->count; $i++) {
            if ($collection->contains($this->heap[$i])) {
                $newHeap[$newCount] = $this->heap[$i];
                $newCount++;
            } else {
                $modified = true;
            }
        }
        
        if ($modified) {
            $this->heap = $newHeap;
            $this->count = $newCount;
            $this->heapify();
            $this->modCount++;
        }
        
        return $modified;
    }
    
    public function clear(): void {
        $this->heap = [];
        $this->count = 0;
        $this->modCount++;
    }
    
    public function toArray(): array {
        $result := [];
        for ($i := 0; $i < $this->count; $i++) {
            $result[$i] = $this->heap[$i];
        }
        return $result;
    }
    
    // ========================================================================
    // IIterable 实现
    // ========================================================================
    
    public function iterator(): PriorityQueueIterator<T> {
        return new PriorityQueueIterator<T>($this);
    }
    
    // ========================================================================
    // 扩展方法
    // ========================================================================
    
    /**
     * 克隆优先队列
     */
    public function clone(): PriorityQueue<T> {
        $copy := new PriorityQueue<T>($this->comparator);
        for ($i := 0; $i < $this->count; $i++) {
            $copy->heap[$i] = $this->heap[$i];
        }
        $copy->count = $this->count;
        return $copy;
    }
    
    /**
     * 返回排序后的数组（不修改原队列）
     */
    public function toSortedArray(): array {
        $copy := $this->clone();
        $result := [];
        $i := 0;
        while (!$copy->isEmpty()) {
            $result[$i] = $copy->poll();
            $i++;
        }
        return $result;
    }
    
    /**
     * 获取比较器
     */
    public function getComparator(): IComparator<T> {
        return $this->comparator;
    }
    
    /**
     * 获取内部数据（供迭代器使用）
     */
    public function getHeap(): array {
        return $this->heap;
    }
    
    public function getModCount(): int {
        return $this->modCount;
    }
    
    // ========================================================================
    // 内部方法
    // ========================================================================
    
    private function compare(mixed $a, mixed $b): int {
        if ($this->comparator != null) {
            return $this->comparator->compare($a, $b);
        }
        if ($a < $b) {
            return -1;
        } else if ($a > $b) {
            return 1;
        }
        return 0;
    }
    
    private function siftUp(int $index): void {
        while ($index > 0) {
            $parent := ($index - 1) / 2;
            if ($this->compare($this->heap[$index], $this->heap[$parent]) >= 0) {
                break;
            }
            $this->swap($index, $parent);
            $index = $parent;
        }
    }
    
    private function siftDown(int $index): void {
        while (true) {
            $left := 2 * $index + 1;
            $right := 2 * $index + 2;
            $smallest := $index;
            
            if ($left < $this->count && $this->compare($this->heap[$left], $this->heap[$smallest]) < 0) {
                $smallest = $left;
            }
            
            if ($right < $this->count && $this->compare($this->heap[$right], $this->heap[$smallest]) < 0) {
                $smallest = $right;
            }
            
            if ($smallest == $index) {
                break;
            }
            
            $this->swap($index, $smallest);
            $index = $smallest;
        }
    }
    
    private function swap(int $i, int $j): void {
        $temp := $this->heap[$i];
        $this->heap[$i] = $this->heap[$j];
        $this->heap[$j] = $temp;
    }
    
    private function removeAt(int $index): void {
        $this->count--;
        if ($this->count == $index) {
            return;
        }
        
        $this->heap[$index] = $this->heap[$this->count];
        $this->siftDown($index);
        
        if ($this->heap[$index] == $this->heap[$this->count]) {
            $this->siftUp($index);
        }
        
        $this->modCount++;
    }
    
    private function heapify(): void {
        for ($i := ($this->count / 2) - 1; $i >= 0; $i--) {
            $this->siftDown($i);
        }
    }
}

/**
 * 逆序比较器（用于创建最大堆）
 */
public class ReverseComparator<T> implements IComparator<T> {
    public function compare(mixed $a, mixed $b): int {
        if ($a < $b) {
            return 1;
        } else if ($a > $b) {
            return -1;
        }
        return 0;
    }
}

/**
 * PriorityQueue 迭代器
 */
public class PriorityQueueIterator<T> implements IIterator<T> {
    private PriorityQueue<T> $queue;
    private int $index;
    private int $expectedModCount;
    
    public function __construct(PriorityQueue<T> $queue) {
        $this->queue = $queue;
        $this->index = 0;
        $this->expectedModCount = $queue->getModCount();
    }
    
    public function hasNext(): bool {
        return $this->index < $this->queue->size();
    }
    
    public function next(): mixed {
        $this->checkForComodification();
        if (!$this->hasNext()) {
            throw new NoSuchElementException();
        }
        
        $heap := $this->queue->getHeap();
        $element := $heap[$this->index];
        $this->index++;
        return $element;
    }
    
    public function remove(): void {
        throw new UnsupportedOperationException("Remove not supported during iteration");
    }
    
    private function checkForComodification(): void {
        if ($this->queue->getModCount() != $this->expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }
}






