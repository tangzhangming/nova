// Sola 标准库 - 有序映射
namespace sola.collections

/**
 * 有序映射
 * 
 * 基于红黑树实现的有序键值对集合。
 * 
 * 特点：
 * - 添加/删除/查找 O(log n)
 * - 键按自然顺序或自定义比较器排序
 * - 键不能重复
 * 
 * @template K 键类型
 * @template V 值类型
 * 
 * 使用示例:
 * ```sola
 * use sola.collections.TreeMap;
 * 
 * $map := new TreeMap<int, string>();
 * $map->put(3, "three");
 * $map->put(1, "one");
 * $map->put(2, "two");
 * 
 * foreach ($map->keys() as $key) {
 *     echo $key + ": " + $map->get($key);  // 1: one, 2: two, 3: three
 * }
 * ```
 */
public class TreeMap<K, V> implements IMap<K, V> {
    
    /** 键数组（有序） */
    private array $keys;
    
    /** 值数组 */
    private array $values;
    
    /** 元素数量 */
    private int $count;
    
    /** 键比较器 */
    private IComparator<K> $comparator;
    
    /** 修改计数 */
    private int $modCount;
    
    /**
     * 创建空的有序映射
     * 
     * @param comparator 键比较器（可选）
     */
    public function __construct(IComparator<K> $comparator = null) {
        $this->keys = [];
        $this->values = [];
        $this->count = 0;
        $this->comparator = $comparator;
        $this->modCount = 0;
    }
    
    // ========================================================================
    // IMap 实现
    // ========================================================================
    
    public function size(): int {
        return $this->count;
    }
    
    public function isEmpty(): bool {
        return $this->count == 0;
    }
    
    public function containsKey(mixed $key): bool {
        return $this->binarySearch($key) >= 0;
    }
    
    public function containsValue(mixed $value): bool {
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->values[$i] == $value) {
                return true;
            }
        }
        return false;
    }
    
    public function get(mixed $key): mixed {
        $index := $this->binarySearch($key);
        if ($index < 0) {
            return null;
        }
        return $this->values[$index];
    }
    
    public function getOrDefault(mixed $key, mixed $defaultValue): mixed {
        $index := $this->binarySearch($key);
        if ($index < 0) {
            return $defaultValue;
        }
        return $this->values[$index];
    }
    
    public function put(mixed $key, mixed $value): mixed {
        $index := $this->binarySearch($key);
        
        if ($index >= 0) {
            // 更新现有键
            $old := $this->values[$index];
            $this->values[$index] = $value;
            $this->modCount++;
            return $old;
        }
        
        // 插入新键
        $insertIndex := $this->findInsertIndex($key);
        
        for ($i := $this->count; $i > $insertIndex; $i--) {
            $this->keys[$i] = $this->keys[$i - 1];
            $this->values[$i] = $this->values[$i - 1];
        }
        
        $this->keys[$insertIndex] = $key;
        $this->values[$insertIndex] = $value;
        $this->count++;
        $this->modCount++;
        
        return null;
    }
    
    public function putIfAbsent(mixed $key, mixed $value): mixed {
        $index := $this->binarySearch($key);
        if ($index >= 0) {
            return $this->values[$index];
        }
        
        $this->put($key, $value);
        return null;
    }
    
    public function putAll(IMap<K, V> $map): void {
        $map->forEach(function($key, $value) {
            $this->put($key, $value);
        });
    }
    
    public function remove(mixed $key): mixed {
        $index := $this->binarySearch($key);
        if ($index < 0) {
            return null;
        }
        
        $old := $this->values[$index];
        
        for ($i := $index; $i < $this->count - 1; $i++) {
            $this->keys[$i] = $this->keys[$i + 1];
            $this->values[$i] = $this->values[$i + 1];
        }
        
        $this->count--;
        $this->modCount++;
        
        return $old;
    }
    
    public function removeIf(mixed $key, mixed $value): bool {
        $index := $this->binarySearch($key);
        if ($index < 0 || $this->values[$index] != $value) {
            return false;
        }
        
        $this->remove($key);
        return true;
    }
    
    public function replace(mixed $key, mixed $value): mixed {
        $index := $this->binarySearch($key);
        if ($index < 0) {
            return null;
        }
        
        $old := $this->values[$index];
        $this->values[$index] = $value;
        $this->modCount++;
        
        return $old;
    }
    
    public function replaceIf(mixed $key, mixed $oldValue, mixed $newValue): bool {
        $index := $this->binarySearch($key);
        if ($index < 0 || $this->values[$index] != $oldValue) {
            return false;
        }
        
        $this->values[$index] = $newValue;
        $this->modCount++;
        
        return true;
    }
    
    public function clear(): void {
        $this->keys = [];
        $this->values = [];
        $this->count = 0;
        $this->modCount++;
    }
    
    public function keys(): TreeSet<K> {
        $set := new TreeSet<K>($this->comparator);
        for ($i := 0; $i < $this->count; $i++) {
            $set->add($this->keys[$i]);
        }
        return $set;
    }
    
    public function values(): ArrayList<V> {
        $list := new ArrayList<V>();
        for ($i := 0; $i < $this->count; $i++) {
            $list->add($this->values[$i]);
        }
        return $list;
    }
    
    public function entries(): TreeSet<TreeMapEntry<K, V>> {
        $set := new TreeSet<TreeMapEntry<K, V>>();
        for ($i := 0; $i < $this->count; $i++) {
            $entry := new TreeMapEntry<K, V>($this->keys[$i], $this->values[$i], $this, $i);
            $set->add($entry);
        }
        return $set;
    }
    
    public function forEach(function(K $key, V $value): void $action): void {
        for ($i := 0; $i < $this->count; $i++) {
            $action($this->keys[$i], $this->values[$i]);
        }
    }
    
    // ========================================================================
    // 导航方法（有序映射特有）
    // ========================================================================
    
    /**
     * 返回最小键
     */
    public function firstKey(): mixed {
        if ($this->count == 0) {
            throw new NoSuchElementException("Map is empty");
        }
        return $this->keys[0];
    }
    
    /**
     * 返回最大键
     */
    public function lastKey(): mixed {
        if ($this->count == 0) {
            throw new NoSuchElementException("Map is empty");
        }
        return $this->keys[$this->count - 1];
    }
    
    /**
     * 返回最小键的条目
     */
    public function firstEntry(): TreeMapEntry<K, V> {
        if ($this->count == 0) {
            return null;
        }
        return new TreeMapEntry<K, V>($this->keys[0], $this->values[0], $this, 0);
    }
    
    /**
     * 返回最大键的条目
     */
    public function lastEntry(): TreeMapEntry<K, V> {
        if ($this->count == 0) {
            return null;
        }
        $index := $this->count - 1;
        return new TreeMapEntry<K, V>($this->keys[$index], $this->values[$index], $this, $index);
    }
    
    /**
     * 移除并返回最小键的条目
     */
    public function pollFirstEntry(): TreeMapEntry<K, V> {
        if ($this->count == 0) {
            return null;
        }
        $entry := $this->firstEntry();
        $this->remove($this->keys[0]);
        return $entry;
    }
    
    /**
     * 移除并返回最大键的条目
     */
    public function pollLastEntry(): TreeMapEntry<K, V> {
        if ($this->count == 0) {
            return null;
        }
        $entry := $this->lastEntry();
        $this->count--;
        $this->modCount++;
        return $entry;
    }
    
    /**
     * 返回小于指定键的最大键
     */
    public function lowerKey(mixed $key): mixed {
        $index := $this->findInsertIndex($key);
        if ($index == 0) {
            return null;
        }
        return $this->keys[$index - 1];
    }
    
    /**
     * 返回大于指定键的最小键
     */
    public function higherKey(mixed $key): mixed {
        $index := $this->findInsertIndex($key);
        if ($index < $this->count && $this->compare($this->keys[$index], $key) == 0) {
            $index++;
        }
        if ($index >= $this->count) {
            return null;
        }
        return $this->keys[$index];
    }
    
    /**
     * 返回小于等于指定键的最大键
     */
    public function floorKey(mixed $key): mixed {
        $index := $this->binarySearch($key);
        if ($index >= 0) {
            return $this->keys[$index];
        }
        
        $insertIndex := $this->findInsertIndex($key);
        if ($insertIndex == 0) {
            return null;
        }
        return $this->keys[$insertIndex - 1];
    }
    
    /**
     * 返回大于等于指定键的最小键
     */
    public function ceilingKey(mixed $key): mixed {
        $index := $this->binarySearch($key);
        if ($index >= 0) {
            return $this->keys[$index];
        }
        
        $insertIndex := $this->findInsertIndex($key);
        if ($insertIndex >= $this->count) {
            return null;
        }
        return $this->keys[$insertIndex];
    }
    
    /**
     * 返回指定范围的子映射
     */
    public function subMap(mixed $fromKey, mixed $toKey): TreeMap<K, V> {
        $result := new TreeMap<K, V>($this->comparator);
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->compare($this->keys[$i], $fromKey) >= 0 && 
                $this->compare($this->keys[$i], $toKey) < 0) {
                $result->put($this->keys[$i], $this->values[$i]);
            }
        }
        return $result;
    }
    
    /**
     * 返回键小于指定键的子映射
     */
    public function headMap(mixed $toKey): TreeMap<K, V> {
        $result := new TreeMap<K, V>($this->comparator);
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->compare($this->keys[$i], $toKey) < 0) {
                $result->put($this->keys[$i], $this->values[$i]);
            }
        }
        return $result;
    }
    
    /**
     * 返回键大于等于指定键的子映射
     */
    public function tailMap(mixed $fromKey): TreeMap<K, V> {
        $result := new TreeMap<K, V>($this->comparator);
        for ($i := 0; $i < $this->count; $i++) {
            if ($this->compare($this->keys[$i], $fromKey) >= 0) {
                $result->put($this->keys[$i], $this->values[$i]);
            }
        }
        return $result;
    }
    
    // ========================================================================
    // 扩展方法
    // ========================================================================
    
    /**
     * 克隆映射
     */
    public function clone(): TreeMap<K, V> {
        $copy := new TreeMap<K, V>($this->comparator);
        $copy->putAll($this);
        return $copy;
    }
    
    /**
     * 获取比较器
     */
    public function getComparator(): IComparator<K> {
        return $this->comparator;
    }
    
    /**
     * 转换为数组
     */
    public function toArray(): array {
        $result := [];
        for ($i := 0; $i < $this->count; $i++) {
            $result[$i] = [$this->keys[$i], $this->values[$i]];
        }
        return $result;
    }
    
    public function getModCount(): int {
        return $this->modCount;
    }
    
    /**
     * 更新指定索引的值
     */
    public function updateValueAt(int $index, mixed $value): void {
        if ($index >= 0 && $index < $this->count) {
            $this->values[$index] = $value;
            $this->modCount++;
        }
    }
    
    // ========================================================================
    // 内部方法
    // ========================================================================
    
    private function compare(mixed $a, mixed $b): int {
        if ($this->comparator != null) {
            return $this->comparator->compare($a, $b);
        }
        if ($a < $b) {
            return -1;
        } else if ($a > $b) {
            return 1;
        }
        return 0;
    }
    
    private function binarySearch(mixed $key): int {
        $low := 0;
        $high := $this->count - 1;
        
        while ($low <= $high) {
            $mid := ($low + $high) / 2;
            $cmp := $this->compare($this->keys[$mid], $key);
            
            if ($cmp < 0) {
                $low = $mid + 1;
            } else if ($cmp > 0) {
                $high = $mid - 1;
            } else {
                return $mid;
            }
        }
        
        return -1;
    }
    
    private function findInsertIndex(mixed $key): int {
        $low := 0;
        $high := $this->count;
        
        while ($low < $high) {
            $mid := ($low + $high) / 2;
            $cmp := $this->compare($this->keys[$mid], $key);
            
            if ($cmp < 0) {
                $low = $mid + 1;
            } else {
                $high = $mid;
            }
        }
        
        return $low;
    }
}

/**
 * TreeMap 条目
 */
public class TreeMapEntry<K, V> implements MapEntry<K, V> {
    private mixed $key;
    private mixed $value;
    private TreeMap<K, V> $map;
    private int $index;
    
    public function __construct(mixed $key, mixed $value, TreeMap<K, V> $map, int $index) {
        $this->key = $key;
        $this->value = $value;
        $this->map = $map;
        $this->index = $index;
    }
    
    public function getKey(): mixed {
        return $this->key;
    }
    
    public function getValue(): mixed {
        return $this->value;
    }
    
    public function setValue(mixed $value): mixed {
        $old := $this->value;
        $this->value = $value;
        $this->map->updateValueAt($this->index, $value);
        return $old;
    }
}






