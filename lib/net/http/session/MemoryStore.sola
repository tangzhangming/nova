// Sola 标准库 - 内存 Session 存储
namespace sola.net.http.session

/**
 * 内存存储条目
 */
public class MemoryStoreEntry {
    public string $id;
    public SessionData $data;
    public int $expireAt;
    
    public function __construct(string $id, SessionData $data, int $expireAt) {
        $this->id = $id;
        $this->data = $data;
        $this->expireAt = $expireAt;
    }
}

/**
 * 内存 Session 存储
 * 
 * 将 Session 数据存储在内存中。
 * 
 * 特点：
 * - 读写速度快
 * - 进程重启后数据丢失
 * - 适用于开发环境或单进程应用
 * 
 * 使用示例：
 * ```sola
 * use sola.net.http.session.MemoryStore;
 * 
 * $store := new MemoryStore();
 * $server->setSessionStore($store);
 * ```
 */
public class MemoryStore implements SessionStore {
    
    /** 存储条目 */
    private MemoryStoreEntry[] $entries;
    
    /** 条目数量 */
    private int $entryCount;
    
    public function __construct() {
        $this->entries = [];
        $this->entryCount = 0;
    }
    
    /**
     * 读取 Session 数据
     */
    public function read(string $id): SessionData {
        $now := native_time();
        
        for ($i := 0; $i < $this->entryCount; $i++) {
            if ($this->entries[$i]->id == $id) {
                // 检查过期
                if ($this->entries[$i]->expireAt > 0 && $this->entries[$i]->expireAt < $now) {
                    $this->removeAt($i);
                    return null;
                }
                
                // 更新最后访问时间
                $this->entries[$i]->data->lastAccessedAt = $now;
                
                return $this->entries[$i]->data;
            }
        }
        
        return null;
    }
    
    /**
     * 写入 Session 数据
     */
    public function write(string $id, SessionData $data, int $lifetime): bool {
        $now := native_time();
        $expireAt := 0;
        if ($lifetime > 0) {
            $expireAt = $now + $lifetime;
        }
        
        // 查找现有条目
        for ($i := 0; $i < $this->entryCount; $i++) {
            if ($this->entries[$i]->id == $id) {
                $this->entries[$i]->data = $data;
                $this->entries[$i]->expireAt = $expireAt;
                return true;
            }
        }
        
        // 创建新条目
        $entry := new MemoryStoreEntry($id, $data, $expireAt);
        $this->entries[$this->entryCount] = $entry;
        $this->entryCount++;
        
        return true;
    }
    
    /**
     * 销毁 Session
     */
    public function destroy(string $id): bool {
        for ($i := 0; $i < $this->entryCount; $i++) {
            if ($this->entries[$i]->id == $id) {
                $this->removeAt($i);
                return true;
            }
        }
        return false;
    }
    
    /**
     * 垃圾回收
     */
    public function gc(int $maxLifetime): int {
        $now := native_time();
        $removed := 0;
        
        $i := 0;
        while ($i < $this->entryCount) {
            $entry := $this->entries[$i];
            
            if ($entry->expireAt > 0 && $entry->expireAt < $now) {
                $this->removeAt($i);
                $removed++;
            } else {
                $i++;
            }
        }
        
        return $removed;
    }
    
    /**
     * 检查 Session 是否存在
     */
    public function exists(string $id): bool {
        $now := native_time();
        
        for ($i := 0; $i < $this->entryCount; $i++) {
            if ($this->entries[$i]->id == $id) {
                if ($this->entries[$i]->expireAt > 0 && $this->entries[$i]->expireAt < $now) {
                    return false;
                }
                return true;
            }
        }
        
        return false;
    }
    
    // ========================================================================
    // 调试方法
    // ========================================================================
    
    /**
     * 获取存储的 Session 数量
     */
    public function count(): int {
        return $this->entryCount;
    }
    
    /**
     * 清空所有 Session
     */
    public function clear(): void {
        $this->entries = [];
        $this->entryCount = 0;
    }
    
    // ========================================================================
    // 内部方法
    // ========================================================================
    
    private function removeAt(int $index): void {
        $newEntries := [];
        $newCount := 0;
        
        for ($i := 0; $i < $this->entryCount; $i++) {
            if ($i != $index) {
                $newEntries[$newCount] = $this->entries[$i];
                $newCount++;
            }
        }
        
        $this->entries = $newEntries;
        $this->entryCount = $newCount;
    }
}






