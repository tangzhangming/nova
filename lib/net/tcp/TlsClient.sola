namespace sola.net.tcp

use sola.lang.Bytes;

/**
 * TLS/SSL 安全连接客户端
 * 
 * 提供基于 TLS/SSL 的安全 TCP 连接功能，支持 HTTPS、SMTPS 等安全协议。
 * 
 * 使用示例：
 * ```sola
 * use sola.net.tcp.TlsClient;
 * 
 * // 连接到 HTTPS 服务器
 * $client := new TlsClient("www.google.com", 443);
 * 
 * // 发送 HTTPS 请求
 * $client->write("GET / HTTP/1.1\r\nHost: www.google.com\r\nConnection: close\r\n\r\n");
 * 
 * // 读取响应
 * while ($client->isConnected()) {
 *     $line := $client->readLine();
 *     if ($line == "") {
 *         break;
 *     }
 *     print($line);
 * }
 * 
 * $client->close();
 * ```
 * 
 * 跳过证书验证（仅用于测试）：
 * ```sola
 * $client := new TlsClient();
 * $client->setSkipVerify(true);
 * $client->connect("self-signed.example.com", 443);
 * ```
 */
public class TlsClient {
    
    // ========================================================================
    // 私有属性
    // ========================================================================
    
    /** 连接句柄 */
    private int $connId = -1;
    
    /** 远程主机 */
    private string $host = "";
    
    /** 远程端口 */
    private int $port = 0;
    
    /** 连接超时（毫秒） */
    private int $connectTimeout = 10000;
    
    /** 读取超时（毫秒） */
    private int $readTimeout = 0;
    
    /** 写入超时（毫秒） */
    private int $writeTimeout = 0;
    
    /** 是否跳过证书验证 */
    private bool $skipVerify = false;
    
    /** 是否启用 KeepAlive */
    private bool $keepAlive = false;
    
    /** KeepAlive 间隔（秒） */
    private int $keepAliveInterval = 0;
    
    /** 是否启用 NoDelay */
    private bool $noDelay = false;
    
    // ========================================================================
    // 构造函数
    // ========================================================================
    
    /**
     * 构造函数
     * 
     * 可以不带参数创建实例，之后调用 connect() 连接；
     * 也可以直接传入主机和端口，自动建立 TLS 安全连接。
     * 
     * @param string $host 远程主机地址（可选）
     * @param int $port 远程端口号（可选，HTTPS 默认 443）
     */
    public function __construct(string $host = "", int $port = 0) {
        if ($host != "" && $port > 0) {
            $this->host = $host;
            $this->port = $port;
            $this->connect($host, $port);
        }
    }
    
    // ========================================================================
    // 连接管理
    // ========================================================================
    
    /**
     * 建立 TLS 安全连接
     * 
     * @param string $host 远程主机地址（如果构造时未指定）
     * @param int $port 远程端口号（如果构造时未指定）
     * @return bool 连接是否成功
     */
    public function connect(string $host = "", int $port = 0): bool {
        // 如果已连接，先关闭
        if ($this->connId >= 0) {
            $this->close();
        }
        
        // 使用参数或已保存的值
        if ($host != "") {
            $this->host = $host;
        }
        if ($port > 0) {
            $this->port = $port;
        }
        
        // 验证参数
        if ($this->host == "" || $this->port <= 0) {
            return false;
        }
        
        // 建立 TLS 连接
        if ($this->skipVerify) {
            $this->connId = native_tls_connect_insecure($this->host, $this->port, $this->connectTimeout);
        } else {
            $this->connId = native_tls_connect($this->host, $this->port, $this->connectTimeout);
        }
        
        if ($this->connId < 0) {
            return false;
        }
        
        // 应用已设置的选项
        $this->applyOptions();
        
        return true;
    }
    
    /**
     * 关闭连接
     * 
     * @return bool 关闭是否成功
     */
    public function close(): bool {
        if ($this->connId < 0) {
            return false;
        }
        $result := native_tcp_close($this->connId);
        $this->connId = -1;
        return $result;
    }
    
    /**
     * 检查连接是否已建立
     * 
     * @return bool 是否已连接
     */
    public function isConnected(): bool {
        if ($this->connId < 0) {
            return false;
        }
        return native_tcp_is_connected($this->connId);
    }
    
    // ========================================================================
    // TLS 特定功能
    // ========================================================================
    
    /**
     * 设置是否跳过证书验证
     * 
     * 警告：仅在测试环境中使用，生产环境应始终验证证书
     * 
     * @param bool $skip 是否跳过验证
     * @return TlsClient 返回自身用于链式调用
     */
    public function setSkipVerify(bool $skip): TlsClient {
        $this->skipVerify = $skip;
        return $this;
    }
    
    /**
     * 检查是否跳过证书验证
     * 
     * @return bool 是否跳过
     */
    public function isSkipVerify(): bool {
        return $this->skipVerify;
    }
    
    /**
     * 获取 TLS 版本
     * 
     * @return string TLS 版本（如 "TLS 1.2", "TLS 1.3"）
     */
    public function getTlsVersion(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tls_get_version($this->connId);
    }
    
    /**
     * 获取使用的加密套件
     * 
     * @return string 加密套件名称
     */
    public function getCipherSuite(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tls_get_cipher_suite($this->connId);
    }
    
    /**
     * 获取服务器名称（SNI）
     * 
     * @return string 服务器名称
     */
    public function getServerName(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tls_get_server_name($this->connId);
    }
    
    // ========================================================================
    // 数据写入
    // ========================================================================
    
    /**
     * 发送字符串数据
     * 
     * @param string $data 要发送的字符串
     * @return int 发送的字节数，失败返回 -1
     */
    public function write(string $data): int {
        if ($this->connId < 0) {
            return -1;
        }
        return native_tcp_write($this->connId, $data);
    }
    
    /**
     * 发送字节数组数据
     * 
     * @param byte[] $data 要发送的字节数组
     * @return int 发送的字节数，失败返回 -1
     */
    public function writeBytes(byte[] $data): int {
        if ($this->connId < 0) {
            return -1;
        }
        return native_tcp_write_bytes($this->connId, $data);
    }
    
    /**
     * 发送一行数据（自动添加换行符）
     * 
     * @param string $data 要发送的字符串
     * @return int 发送的字节数，失败返回 -1
     */
    public function writeLine(string $data): int {
        return $this->write($data + "\n");
    }
    
    // ========================================================================
    // 数据读取
    // ========================================================================
    
    /**
     * 读取字符串数据
     * 
     * @param int $length 要读取的最大字节数
     * @return string 读取的字符串，失败返回空字符串
     */
    public function read(int $length): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_read($this->connId, $length);
    }
    
    /**
     * 读取字节数组数据
     * 
     * @param int $length 要读取的最大字节数
     * @return byte[] 读取的字节数组
     */
    public function readBytes(int $length): byte[] {
        if ($this->connId < 0) {
            return Bytes::alloc(0);
        }
        return native_tcp_read_bytes($this->connId, $length);
    }
    
    /**
     * 精确读取指定长度的数据
     * 
     * @param int $length 要读取的精确字节数
     * @return byte[] 读取的字节数组
     */
    public function readExact(int $length): byte[] {
        if ($this->connId < 0) {
            return Bytes::alloc(0);
        }
        return native_tcp_read_exact($this->connId, $length);
    }
    
    /**
     * 读取一行数据
     * 
     * @return string 读取的一行，包含换行符
     */
    public function readLine(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_read_line($this->connId);
    }
    
    /**
     * 读取直到遇到指定的分隔符
     * 
     * @param string $delimiter 分隔符
     * @return string 读取的数据
     */
    public function readUntil(string $delimiter): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_read_until($this->connId, $delimiter);
    }
    
    /**
     * 获取缓冲区中可读的字节数
     * 
     * @return int 可读字节数
     */
    public function available(): int {
        if ($this->connId < 0) {
            return 0;
        }
        return native_tcp_available($this->connId);
    }
    
    /**
     * 刷新输出缓冲区
     * 
     * @return bool 是否成功
     */
    public function flush(): bool {
        if ($this->connId < 0) {
            return false;
        }
        return native_tcp_flush($this->connId);
    }
    
    // ========================================================================
    // 超时配置
    // ========================================================================
    
    /**
     * 设置连接超时时间
     * 
     * @param int $ms 超时时间（毫秒）
     * @return TlsClient 返回自身用于链式调用
     */
    public function setConnectTimeout(int $ms): TlsClient {
        $this->connectTimeout = $ms;
        return $this;
    }
    
    /**
     * 获取连接超时时间
     * 
     * @return int 超时时间（毫秒）
     */
    public function getConnectTimeout(): int {
        return $this->connectTimeout;
    }
    
    /**
     * 设置读取超时时间
     * 
     * @param int $ms 超时时间（毫秒）
     * @return TlsClient 返回自身用于链式调用
     */
    public function setReadTimeout(int $ms): TlsClient {
        $this->readTimeout = $ms;
        if ($this->connId >= 0) {
            native_tcp_set_read_timeout($this->connId, $ms);
        }
        return $this;
    }
    
    /**
     * 获取读取超时时间
     * 
     * @return int 超时时间（毫秒）
     */
    public function getReadTimeout(): int {
        return $this->readTimeout;
    }
    
    /**
     * 设置写入超时时间
     * 
     * @param int $ms 超时时间（毫秒）
     * @return TlsClient 返回自身用于链式调用
     */
    public function setWriteTimeout(int $ms): TlsClient {
        $this->writeTimeout = $ms;
        if ($this->connId >= 0) {
            native_tcp_set_write_timeout($this->connId, $ms);
        }
        return $this;
    }
    
    /**
     * 获取写入超时时间
     * 
     * @return int 超时时间（毫秒）
     */
    public function getWriteTimeout(): int {
        return $this->writeTimeout;
    }
    
    /**
     * 设置通用超时
     * 
     * @param int $seconds 超时时间（秒）
     * @return bool 是否成功
     */
    public function setTimeout(int $seconds): bool {
        if ($this->connId < 0) {
            return false;
        }
        return native_tcp_set_timeout($this->connId, $seconds);
    }
    
    /**
     * 清除所有超时设置
     * 
     * @return bool 是否成功
     */
    public function clearTimeout(): bool {
        if ($this->connId < 0) {
            return false;
        }
        $this->readTimeout = 0;
        $this->writeTimeout = 0;
        return native_tcp_clear_timeout($this->connId);
    }
    
    // ========================================================================
    // Socket 选项配置
    // ========================================================================
    
    /**
     * 设置 KeepAlive
     * 
     * @param bool $enabled 是否启用
     * @param int $intervalSeconds KeepAlive 间隔（秒）
     * @return TlsClient 返回自身用于链式调用
     */
    public function setKeepAlive(bool $enabled, int $intervalSeconds = 0): TlsClient {
        $this->keepAlive = $enabled;
        $this->keepAliveInterval = $intervalSeconds;
        if ($this->connId >= 0) {
            native_tcp_set_keepalive($this->connId, $enabled, $intervalSeconds);
        }
        return $this;
    }
    
    /**
     * 设置 NoDelay
     * 
     * @param bool $enabled 是否启用
     * @return TlsClient 返回自身用于链式调用
     */
    public function setNoDelay(bool $enabled): TlsClient {
        $this->noDelay = $enabled;
        if ($this->connId >= 0) {
            native_tcp_set_nodelay($this->connId, $enabled);
        }
        return $this;
    }
    
    // ========================================================================
    // 地址信息
    // ========================================================================
    
    /**
     * 获取远程主机地址
     * 
     * @return string 主机地址
     */
    public function getRemoteHost(): string {
        if ($this->connId < 0) {
            return $this->host;
        }
        return native_tcp_get_remote_host($this->connId);
    }
    
    /**
     * 获取远程端口
     * 
     * @return int 端口号
     */
    public function getRemotePort(): int {
        if ($this->connId < 0) {
            return $this->port;
        }
        return native_tcp_get_remote_port($this->connId);
    }
    
    /**
     * 获取远程完整地址
     * 
     * @return string 完整地址（host:port）
     */
    public function getRemoteAddress(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_get_remote_addr($this->connId);
    }
    
    /**
     * 获取本地主机地址
     * 
     * @return string 主机地址
     */
    public function getLocalHost(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_get_local_host($this->connId);
    }
    
    /**
     * 获取本地端口
     * 
     * @return int 端口号
     */
    public function getLocalPort(): int {
        if ($this->connId < 0) {
            return 0;
        }
        return native_tcp_get_local_port($this->connId);
    }
    
    /**
     * 获取本地完整地址
     * 
     * @return string 完整地址（host:port）
     */
    public function getLocalAddress(): string {
        if ($this->connId < 0) {
            return "";
        }
        return native_tcp_get_local_addr($this->connId);
    }
    
    // ========================================================================
    // 静态工厂方法
    // ========================================================================
    
    /**
     * 创建并建立 TLS 安全连接
     * 
     * @param string $host 远程主机地址
     * @param int $port 远程端口号
     * @return TlsClient 新的 TlsClient 实例
     */
    public static function create(string $host, int $port): TlsClient {
        return new TlsClient($host, $port);
    }
    
    /**
     * 创建带有自定义超时的 TLS 连接
     * 
     * @param string $host 远程主机地址
     * @param int $port 远程端口号
     * @param int $timeoutMs 连接超时（毫秒）
     * @return TlsClient 新的 TlsClient 实例
     */
    public static function createWithTimeout(string $host, int $port, int $timeoutMs): TlsClient {
        $client := new TlsClient();
        $client->setConnectTimeout($timeoutMs);
        $client->connect($host, $port);
        return $client;
    }
    
    /**
     * 创建不验证证书的 TLS 连接（仅用于测试）
     * 
     * @param string $host 远程主机地址
     * @param int $port 远程端口号
     * @return TlsClient 新的 TlsClient 实例
     */
    public static function createInsecure(string $host, int $port): TlsClient {
        $client := new TlsClient();
        $client->setSkipVerify(true);
        $client->connect($host, $port);
        return $client;
    }
    
    // ========================================================================
    // 私有方法
    // ========================================================================
    
    /**
     * 应用已设置的选项到新连接
     */
    private function applyOptions() {
        if ($this->connId < 0) {
            return;
        }
        
        // 应用超时设置
        if ($this->readTimeout > 0) {
            native_tcp_set_read_timeout($this->connId, $this->readTimeout);
        }
        if ($this->writeTimeout > 0) {
            native_tcp_set_write_timeout($this->connId, $this->writeTimeout);
        }
        
        // 应用 Socket 选项
        if ($this->keepAlive) {
            native_tcp_set_keepalive($this->connId, true, $this->keepAliveInterval);
        }
        if ($this->noDelay) {
            native_tcp_set_nodelay($this->connId, true);
        }
    }
}










