# Sola 语言并发模型文档

> 版本: 1.0  
> 更新日期: 2026-01-10

## 概述

Sola 语言采用 **CSP (Communicating Sequential Processes)** 风格的并发模型，主要通过协程（Goroutine）和通道（Channel）实现并发编程。

## 核心概念

### 1. 协程 (Goroutine)

协程是 Sola 语言中的轻量级执行单元，由语言运行时管理和调度。

#### 特性

- **轻量级**: 每个协程栈初始大小约 4KB，远小于操作系统线程
- **协作式调度**: 协程在特定点主动让出执行权（非抢占式）
- **独立栈**: 每个协程拥有独立的调用栈和局部变量
- **父子关系**: 协程创建时记录父协程 ID，用于调试和追踪

#### 状态机

```
┌──────────────┐
│  Runnable    │ ←──────────────────┐
│  (可运行)     │                    │
└──────┬───────┘                    │
       │ 被调度                       │ 被唤醒
       ▼                            │
┌──────────────┐                    │
│  Running     │ ──────────────────►│
│  (运行中)     │      阻塞           │
└──────┬───────┘                    │
       │                            │
       │ 正常结束/异常               │
       ▼                            │
┌──────────────┐    ┌──────────────┐
│    Dead      │    │   Blocked    │
│  (已死亡)     │    │   (阻塞)     │ ─┘
└──────────────┘    └──────────────┘
```

### 2. 通道 (Channel)

通道是协程间通信的主要机制，遵循"不要通过共享内存来通信，而要通过通信来共享内存"的原则。

#### 通道类型

```sola
// 无缓冲通道 - 同步通信
let ch = channel<int>()

// 有缓冲通道 - 异步通信
let buffered = channel<string>(10)

// 类型化通道 - 运行时类型检查
let typed = channel<User>()
```

#### 通道操作语义

| 操作 | 无缓冲通道 | 有缓冲通道 (未满) | 有缓冲通道 (已满) | 已关闭通道 |
|------|----------|-----------------|-----------------|-----------|
| 发送 | 阻塞等待接收者 | 立即返回 | 阻塞等待空间 | panic |
| 接收 | 阻塞等待发送者 | 立即返回 | 阻塞等待数据 | 返回零值 |

### 3. Select 语句

`select` 允许协程同时等待多个通道操作。

```sola
select {
    case msg <- ch1:
        // 从 ch1 接收到消息
        print("received: " + msg)
    case ch2 <- value:
        // 向 ch2 发送成功
        print("sent")
    default:
        // 没有通道就绪时执行
        print("no activity")
}
```

## 调度策略

### 调度器设计

Sola 当前使用 **单线程协作式调度器**：

- **调度队列**: FIFO 队列管理可运行协程
- **时间片**: 默认 1000 条字节码指令后切换
- **阻塞处理**: 通道阻塞时从运行队列移除
- **唤醒机制**: 阻塞条件满足时重新加入队列

### 调度点

协程在以下情况主动让出执行权：

1. **时间片用尽**: 执行指定数量的指令后
2. **通道阻塞**: 发送/接收操作需要等待
3. **select 等待**: 等待多个通道
4. **主动让出**: 调用 yield() 函数

## 线程安全保证

### 当前实现约束

⚠️ **重要**: 当前 VM 为 **单线程模型**：

- 所有协程在同一个操作系统线程中执行
- 协程切换只发生在明确的调度点
- 无需考虑多线程数据竞争

### 共享状态

| 共享类型 | 安全性 | 说明 |
|---------|-------|------|
| 局部变量 | ✅ 安全 | 每个协程独立栈 |
| 全局变量 | ⚠️ 注意 | 协程间可见，需通过通道协调 |
| 对象字段 | ⚠️ 注意 | 共享引用需小心 |
| 通道 | ✅ 安全 | 内置同步机制 |

## 死锁检测

Sola 运行时提供死锁检测功能：

### 检测条件

- 所有活跃协程都处于阻塞状态
- 没有协程可以被唤醒
- 检测等待循环（A 等 B，B 等 A）

### 使用方式

```sola
// 运行时自动检测
// 死锁时输出详细报告：
// - 阻塞的协程列表
// - 阻塞原因
// - 等待循环（如果存在）
```

## 最佳实践

### 推荐做法

1. **优先使用通道通信**
   ```sola
   // ✅ 好：通过通道传递数据
   ch <- result
   ```

2. **避免共享可变状态**
   ```sola
   // ✅ 好：每个协程处理自己的数据副本
   go {
       let local = copy(shared)
       process(local)
   }
   ```

3. **使用带缓冲通道减少阻塞**
   ```sola
   // ✅ 好：生产者消费者模式
   let queue = channel<Task>(100)
   ```

4. **总是检查通道关闭**
   ```sola
   // ✅ 好：处理通道关闭
   while true {
       let (value, ok) = <-ch
       if !ok { break }
       process(value)
   }
   ```

### 避免的模式

1. **忙等待**
   ```sola
   // ❌ 坏：消耗 CPU
   while !ready { }
   
   // ✅ 好：使用通道
   <-readyCh
   ```

2. **无界并发**
   ```sola
   // ❌ 坏：可能创建太多协程
   for item in items {
       go { process(item) }
   }
   
   // ✅ 好：使用工作池
   let pool = WorkerPool(10)
   pool.submit(items)
   ```

## 未来规划

### 多线程支持 (计划中)

- 可选的多线程模式
- 工作窃取调度
- 原子操作原语
- 线程本地存储

### 高级特性 (计划中)

- 协程取消和超时
- 上下文传播 (Context)
- 结构化并发
- 异步 I/O 集成

## 附录：与其他语言对比

| 特性 | Sola | Go | Python | JavaScript |
|-----|------|-----|--------|------------|
| 并发原语 | 协程 + 通道 | goroutine + channel | async/await + asyncio | async/await + Promise |
| 调度模型 | 协作式 | 抢占式 (1.14+) | 协作式 | 事件循环 |
| 线程模型 | 单线程 | M:N | GIL | 单线程 |
| 通道 | ✅ | ✅ | ❌ (需第三方) | ❌ |
| select | ✅ | ✅ | ❌ | ❌ |

---

*文档由 Sola 语言开发团队维护*
