// Sola 标准库 - MySQL Protocol 实现
namespace sola.database.mysql

use sola.lang.{Str, Bytes};
use sola.net.tcp.TcpClient;
use sola.database.DatabaseException;
use sola.crypto.Hash;

/**
 * MySQL Protocol 实现
 * 
 * 实现 MySQL 客户端协议，包括握手、认证、查询和结果集解析。
 */
public class MysqlProtocol {
    
    private TcpClient $tcp;
    private int $sequenceId = 0;
    private int $capabilities = 0;
    private string $charset = "utf8mb4";
    private int $lastInsertId = 0;
    private int $affectedRows = 0;
    
    public function __construct(TcpClient $tcp) {
        $this->tcp = $tcp;
    }
    
    /**
     * 执行握手和认证
     */
    public function handshake(string $user, string $password, string $database): void {
        // 读取初始握手包
        $handshake := $this->readPacket();
        if (len($handshake) < 5) {
            throw new DatabaseException("Invalid handshake packet");
        }
        
        // 解析协议版本
        $pos := 0;
        $protocolVersion := Bytes::get($handshake, $pos);
        $pos++;
        
        // 跳过服务器版本字符串（以 null 结尾）
        while ($pos < len($handshake) && Bytes::get($handshake, $pos) != 0) {
            $pos++;
        }
        $pos++; // 跳过 null
        
        // 读取连接 ID（4 字节，小端序）
        if ($pos + 4 > len($handshake)) {
            throw new DatabaseException("Invalid handshake packet");
        }
        $pos = $pos + 4;
        
        // 读取 auth-plugin-data-part-1（8 字节）
        if ($pos + 8 > len($handshake)) {
            throw new DatabaseException("Invalid handshake packet");
        }
        $authData1 := Bytes::slice($handshake, $pos, 8);
        $pos = $pos + 8;
        
        // 跳过 filler（1 字节）
        if ($pos < len($handshake)) {
            $pos++;
        }
        
        // 读取 capability flags（低 16 位）
        if ($pos + 2 > len($handshake)) {
            throw new DatabaseException("Invalid handshake packet");
        }
        $capLow := $this->readUint16LE($handshake, $pos);
        $pos = $pos + 2;
        
        // 读取字符集（1 字节）
        if ($pos >= len($handshake)) {
            $this->capabilities = $capLow;
            $this->charset = "utf8mb4";
        } else {
            $this->charset = "" + Bytes::get($handshake, $pos);
            $pos++;
            
            // 读取 status flags（2 字节）
            if ($pos + 2 <= len($handshake)) {
                $pos = $pos + 2;
            }
            
            // 读取 capability flags（高 16 位）
            if ($pos + 2 <= len($handshake)) {
                $capHigh := $this->readUint16LE($handshake, $pos);
                $this->capabilities = $capLow | ($capHigh << 16);
            } else {
                $this->capabilities = $capLow;
            }
        }
        
        // 构建认证响应
        $authResponse := $this->buildAuthResponse($user, $password, $authData1, $database);
        $this->writePacket($authResponse);
        
        // 读取认证结果
        $authResult := $this->readPacket();
        if (len($authResult) > 0 && Bytes::get($authResult, 0) == 0xff) {
            $errorMsg := $this->parseErrorPacket($authResult);
            throw new DatabaseException("Authentication failed: " + $errorMsg);
        }
    }
    
    /**
     * 执行查询
     */
    public function query(string $sql): MysqlResult {
        // 发送 COM_QUERY 命令（0x03）
        $sqlBytes := Bytes::fromString($sql);
        $queryPacket := Bytes::alloc(1 + len($sqlBytes));
        Bytes::set($queryPacket, 0, 0x03); // COM_QUERY
        for ($i := 0; $i < len($sqlBytes); $i++) {
            Bytes::set($queryPacket, $i + 1, Bytes::get($sqlBytes, $i));
        }
        $this->writePacket($queryPacket);
        
        // 读取响应
        $response := $this->readPacket();
        
        if (len($response) == 0) {
            throw new DatabaseException("Empty response");
        }
        
        $firstByte := Bytes::get($response, 0);
        
        // 检查是否是错误包（0xff）
        if ($firstByte == 0xff) {
            $errorMsg := $this->parseErrorPacket($response);
            throw new DatabaseException("Query failed: " + $errorMsg);
        }
        
        // 检查是否是 OK 包（0x00）
        if ($firstByte == 0x00) {
            $this->parseOkPacket($response);
            return new MysqlResult([], [], 0);
        }
        
        // 结果集包（0x01-0xfa 是列数）
        return $this->parseResultSet($response);
    }
    
    /**
     * 获取最后插入的 ID
     */
    public function getLastInsertId(): int {
        return $this->lastInsertId;
    }
    
    /**
     * 获取受影响的行数
     */
    public function getAffectedRows(): int {
        return $this->affectedRows;
    }
    
    /**
     * 读取一个 MySQL 数据包
     */
    private function readPacket(): byte[] {
        // 读取包头（4 字节：3 字节长度 + 1 字节序列号）
        $lenBytes := $this->tcp->readExact(4);
        if (len($lenBytes) < 4) {
            return Bytes::alloc(0);
        }
        
        $b0 := Bytes::get($lenBytes, 0);
        $b1 := Bytes::get($lenBytes, 1);
        $b2 := Bytes::get($lenBytes, 2);
        $b3 := Bytes::get($lenBytes, 3);
        
        $packetLength := $b0 | ($b1 << 8) | ($b2 << 16);
        $this->sequenceId = $b3;
        
        // 读取包体
        if ($packetLength == 0) {
            return Bytes::alloc(0);
        }
        
        return $this->tcp->readExact($packetLength);
    }
    
    /**
     * 写入一个 MySQL 数据包
     */
    private function writePacket(byte[] $data): void {
        $length := len($data);
        $packet := Bytes::alloc(4 + $length);
        
        // 包长度（3 字节，小端序）
        Bytes::set($packet, 0, $length & 0xff);
        Bytes::set($packet, 1, ($length >> 8) & 0xff);
        Bytes::set($packet, 2, ($length >> 16) & 0xff);
        
        // 序列号
        $this->sequenceId = ($this->sequenceId + 1) & 0xff;
        Bytes::set($packet, 3, $this->sequenceId);
        
        // 包体
        for ($i := 0; $i < $length; $i++) {
            Bytes::set($packet, $i + 4, Bytes::get($data, $i));
        }
        
        $this->tcp->writeBytes($packet);
        $this->tcp->flush();
    }
    
    /**
     * 构建认证响应
     */
    private function buildAuthResponse(string $user, string $password, byte[] $authData1, string $database): byte[] {
        $userBytes := Bytes::fromString($user);
        $dbBytes := Bytes::fromString($database);
        
        // MySQL native_password 认证算法
        // token = SHA1(password) XOR SHA1(auth_data + SHA1(SHA1(password)))
        
        // 计算 SHA1(password)
        $sha1Password := Hash::sha1Bytes($password);
        
        // 计算 SHA1(SHA1(password))
        $sha1Sha1Password := Hash::sha1Bytes($sha1Password);
        
        // 拼接 auth_data (8字节) + SHA1(SHA1(password)) (20字节)
        $authDataFull := Bytes::alloc(28);
        for ($i := 0; $i < 8 && $i < len($authData1); $i++) {
            Bytes::set($authDataFull, $i, Bytes::get($authData1, $i));
        }
        for ($i := 0; $i < 20 && $i < len($sha1Sha1Password); $i++) {
            Bytes::set($authDataFull, 8 + $i, Bytes::get($sha1Sha1Password, $i));
        }
        
        // 计算 SHA1(auth_data + SHA1(SHA1(password)))
        $sha1AuthData := Hash::sha1Bytes($authDataFull);
        
        // XOR: SHA1(password) XOR SHA1(auth_data + SHA1(SHA1(password)))
        $token := Bytes::alloc(20);
        for ($i := 0; $i < 20; $i++) {
            $pwdByte := $i < len($sha1Password) ? Bytes::get($sha1Password, $i) : 0;
            $authByte := $i < len($sha1AuthData) ? Bytes::get($sha1AuthData, $i) : 0;
            Bytes::set($token, $i, $pwdByte ^ $authByte);
        }
        
        $passwordBytes := $token;
        
        // 计算响应长度
        $responseLen := 4 + 4 + 1 + 23 + len($userBytes) + 1 + 1 + len($passwordBytes) + len($dbBytes) + 1;
        
        $response := Bytes::alloc($responseLen);
        $pos := 0;
        
        // Capability flags（低 16 位）
        $capLow := $this->capabilities & 0xffff;
        Bytes::set($response, $pos, $capLow & 0xff);
        Bytes::set($response, $pos + 1, ($capLow >> 8) & 0xff);
        $pos = $pos + 2;
        
        // Capability flags（高 16 位）
        $capHigh := ($this->capabilities >> 16) & 0xffff;
        Bytes::set($response, $pos, $capHigh & 0xff);
        Bytes::set($response, $pos + 1, ($capHigh >> 8) & 0xff);
        $pos = $pos + 2;
        
        // Max packet size（4 字节，默认 16MB）
        $maxPacket := 16777216;
        Bytes::set($response, $pos, $maxPacket & 0xff);
        Bytes::set($response, $pos + 1, ($maxPacket >> 8) & 0xff);
        Bytes::set($response, $pos + 2, ($maxPacket >> 16) & 0xff);
        Bytes::set($response, $pos + 3, ($maxPacket >> 24) & 0xff);
        $pos = $pos + 4;
        
        // Character set（1 字节）
        Bytes::set($response, $pos, 0x21); // utf8mb4
        $pos++;
        
        // Reserved（23 字节，全 0）
        for ($i := 0; $i < 23; $i++) {
            Bytes::set($response, $pos + $i, 0);
        }
        $pos = $pos + 23;
        
        // Username
        for ($i := 0; $i < len($userBytes); $i++) {
            Bytes::set($response, $pos + $i, Bytes::get($userBytes, $i));
        }
        $pos = $pos + len($userBytes);
        Bytes::set($response, $pos, 0); // null terminator
        $pos++;
        
        // Auth response length
        Bytes::set($response, $pos, len($passwordBytes) > 255 ? 255 : len($passwordBytes));
        $pos++;
        
        // Password
        for ($i := 0; $i < len($passwordBytes); $i++) {
            Bytes::set($response, $pos + $i, Bytes::get($passwordBytes, $i));
        }
        $pos = $pos + len($passwordBytes);
        
        // Database
        if (len($dbBytes) > 0) {
            for ($i := 0; $i < len($dbBytes); $i++) {
                Bytes::set($response, $pos + $i, Bytes::get($dbBytes, $i));
            }
            $pos = $pos + len($dbBytes);
        }
        Bytes::set($response, $pos, 0); // null terminator
        
        return $response;
    }
    
    /**
     * 解析结果集
     */
    private function parseResultSet(byte[] $columnCountPacket): MysqlResult {
        $pos := 0;
        $columnCount := $this->readLengthEncodedInt($columnCountPacket, $pos);
        
        // 读取列定义
        $columnNames := [];
        for ($i := 0; $i < $columnCount; $i++) {
            $columnDef := $this->readPacket();
            $name := $this->parseColumnName($columnDef);
            push($columnNames, $name);
        }
        
        // 读取 EOF 包
        $eof1 := $this->readPacket();
        
        // 读取数据行
        $rows := [];
        $maxRows := 1000000;
        $rowCount := 0;
        
        while (true) {
            if ($rowCount >= $maxRows) {
                throw new DatabaseException("Result set too large");
            }
            
            $rowPacket := $this->readPacket();
            
            if (len($rowPacket) == 0) {
                break;
            }
            
            // 检查是否是 EOF 包
            if (len($rowPacket) >= 1 && Bytes::get($rowPacket, 0) == 0xfe) {
                if (len($rowPacket) < 9) {
                    break;
                }
                if (len($rowPacket) <= 10) {
                    break;
                }
            }
            
            // 检查是否是错误包
            if (len($rowPacket) >= 1 && Bytes::get($rowPacket, 0) == 0xff) {
                $errorMsg := $this->parseErrorPacket($rowPacket);
                throw new DatabaseException("Query failed: " + $errorMsg);
            }
            
            $rowData := $this->parseRowData($rowPacket, $columnCount);
            push($rows, $rowData);
            $rowCount++;
        }
        
        return new MysqlResult($columnNames, $rows, len($rows));
    }
    
    /**
     * 解析列名
     */
    private function parseColumnName(byte[] $columnDef): string {
        $pos := 0;
        
        // 跳过前 4 个字段 (catalog, schema, table, org_table)
        for ($i := 0; $i < 4; $i++) {
            $pos = $pos + $this->skipLengthEncodedString($columnDef, $pos);
        }
        
        // 读取 name
        $nameLen := $this->readLengthEncodedInt($columnDef, $pos);
        $lenSize := $this->getLengthEncodedIntSize($columnDef, $pos);
        $pos = $pos + $lenSize;
        
        if ($nameLen > 0 && $pos + $nameLen <= len($columnDef)) {
            $nameBytes := Bytes::slice($columnDef, $pos, $nameLen);
            return Bytes::toString($nameBytes);
        }
        
        return "column";
    }
    
    /**
     * 解析行数据
     */
    private function parseRowData(byte[] $rowPacket, int $columnCount): string[] {
        $values := [];
        $pos := 0;
        
        for ($i := 0; $i < $columnCount; $i++) {
            if ($pos >= len($rowPacket)) {
                push($values, "");
                continue;
            }
            
            // 检查是否是 NULL（0xfb）
            if (Bytes::get($rowPacket, $pos) == 0xfb) {
                push($values, "");
                $pos++;
                continue;
            }
            
            // 读取长度编码字符串
            $len := $this->readLengthEncodedInt($rowPacket, $pos);
            $lenSize := $this->getLengthEncodedIntSize($rowPacket, $pos);
            $pos = $pos + $lenSize;
            
            if ($len > 0 && $pos + $len <= len($rowPacket)) {
                $valueBytes := Bytes::slice($rowPacket, $pos, $len);
                push($values, Bytes::toString($valueBytes));
                $pos = $pos + $len;
            } else {
                push($values, "");
            }
        }
        
        return $values;
    }
    
    /**
     * 读取长度编码整数
     */
    private function readLengthEncodedInt(byte[] $data, int $pos): int {
        if ($pos >= len($data)) {
            return 0;
        }
        
        $firstByte := Bytes::get($data, $pos);
        
        if ($firstByte < 0xfb) {
            return $firstByte;
        } else if ($firstByte == 0xfc) {
            if ($pos + 2 > len($data)) {
                return 0;
            }
            return Bytes::get($data, $pos + 1) | (Bytes::get($data, $pos + 2) << 8);
        } else if ($firstByte == 0xfd) {
            if ($pos + 3 > len($data)) {
                return 0;
            }
            return Bytes::get($data, $pos + 1) | (Bytes::get($data, $pos + 2) << 8) | (Bytes::get($data, $pos + 3) << 16);
        } else if ($firstByte == 0xfe) {
            if ($pos + 8 > len($data)) {
                return 0;
            }
            return Bytes::get($data, $pos + 1) | (Bytes::get($data, $pos + 2) << 8) | (Bytes::get($data, $pos + 3) << 16) | (Bytes::get($data, $pos + 4) << 24);
        }
        
        return 0;
    }
    
    /**
     * 获取长度编码整数的大小
     */
    private function getLengthEncodedIntSize(byte[] $data, int $pos): int {
        if ($pos >= len($data)) {
            return 1;
        }
        
        $firstByte := Bytes::get($data, $pos);
        if ($firstByte < 0xfb) {
            return 1;
        } else if ($firstByte == 0xfc) {
            return 3;
        } else if ($firstByte == 0xfd) {
            return 4;
        } else if ($firstByte == 0xfe) {
            return 9;
        }
        
        return 1;
    }
    
    /**
     * 跳过长度编码字符串
     */
    private function skipLengthEncodedString(byte[] $data, int $pos): int {
        $len := $this->readLengthEncodedInt($data, $pos);
        $lenSize := $this->getLengthEncodedIntSize($data, $pos);
        return $lenSize + $len;
    }
    
    /**
     * 解析 OK 包
     */
    private function parseOkPacket(byte[] $packet): void {
        $pos := 1; // 跳过 0x00
        
        $this->affectedRows = $this->readLengthEncodedInt($packet, $pos);
        $pos = $pos + $this->getLengthEncodedIntSize($packet, $pos);
        
        $this->lastInsertId = $this->readLengthEncodedInt($packet, $pos);
    }
    
    /**
     * 解析错误包
     */
    private function parseErrorPacket(byte[] $packet): string {
        if (len($packet) < 5) {
            return "Unknown error";
        }
        
        $pos := 1; // 跳过 0xff
        $errorCode := $this->readUint16LE($packet, $pos);
        $pos = $pos + 2;
        
        // 跳过 SQL state marker
        if ($pos < len($packet) && Bytes::get($packet, $pos) == 0x23) {
            $pos = $pos + 6;
        }
        
        // 读取错误消息
        if ($pos < len($packet)) {
            return Bytes::toString(Bytes::slice($packet, $pos));
        }
        
        return "Error code: " + $errorCode;
    }
    
    /**
     * 读取小端序 uint16
     */
    private function readUint16LE(byte[] $data, int $pos): int {
        if ($pos + 1 >= len($data)) {
            return 0;
        }
        return Bytes::get($data, $pos) | (Bytes::get($data, $pos + 1) << 8);
    }
}
